# An introduction to immutable infrastructure
왜 인프라스트럭처를 관리하지 않고, 프로그래밍해야하는가.

By Josh Stella June 9, 2015

- original article: https://www.oreilly.com/ideas/an-introduction-to-immutable-infrastructure

-----
불변의 인프라스트럭처(Immutable infrastructure, II)는자동화와 프로그래밍을 통한 성공패턴을 활용해서 어플리케이션에 대한 안정성, 효율성 그리고 무중단에 대한 약속을 제공한다. 아직 변경불가 인프라스트럭처(II)에 대한 명확하고 표준화된 정의는 존재하지 않는다. 하지만 기본 사상은 사용자가 불변(immutability) 프로그래밍 컨셉을 사용해서 인프라스트럭처를 생성하고 운영하는 것이다. 무언가를 한번 생성하면, 다시는 바꾸지 않는다는 개념이다. 대신에 기존 인스턴스를 새로운 인스턴스로 대체하여 원하는 방식으로 작동케하는 개념이다.

채드 포울러(Chad Fowler)는 2013 블로그글에 "immutable infrastructure" 용어를 사용해서 "기존 서버는 쓰레기통에 버리고, 코드는 불태워버려라: 변경불가 인프라스트럭쳐와 폐기가능한 컴퍼넌트". 또한 다른 사람들도 유사한 개념을 말하고 있다. 마틴 포울러(Martin Fowler)는 2012년 불사조 서버라고 설명하고 있으며, 그렉 오즐(Greg Orzell), 제임스 카(James Carr), 키프 모리스(키프 모리스), 그리고 벤 버틀러-콜(Ben Butler-Cole) 등도 이에 대한 굉장한 사고와 작업을 내놓았다.

II는 운영환경의 완전 자동화를 필요로 한다. 또한컴퓨트 환경의 완전자동화를 구현하기 위해서는 환경 설정과 모니터링이 모두 API를 통해서 통신되도록 해야한다. 그러므로 II는 진정한 클라우드 환경에서면 실현가능하다. 물론 일부 요소를 구현해서 II의 일부 잇점을 얻을 수는 있다. 그러나 효율성과 장애극복이라는 II의 효과는 클라우드 환경를 통해서만 구현될 수 있다.

## 전문가가 관리하는 인프라스트럭쳐를 포기하라Give up on artisanal infrastructure
역사적으로, 시스템 관리자가 신경을 곤두세우는 요소는 시스템 업타입(살아있는 시간)과 유지보수였다. 왜냐면 전체 서비스와 어플리케이션이 그것들과 관계되어있다고 믿기 때문이다. 데이터센터에서 하드웨어는 매우 고가이기 때문에, 각 시스템들을 잘 관리해야 투자대비 효용성을 뽑아낼 수 있다. 반면 클라우드에서, 이런 사고는 시대착오적인 생각이고, 이런 생각을 버려야 좀 더 안정적이고, 더 단순하고 최종적으로는 안전한 서비스와 어플리케이션을 만들어낼 수 있다. 워너 보글(Wener Vogels, 아마존의CTO 이자 클라우드 시스템의 선구자)은 "서버를 끌어안고 있지 마라"라고 우리에게 얘기한다. 사실 우리가 서버를 안고있다해서 서버는 우리를 알아주지 않는다.

공들여서 관리하는 전통적인 방식의, 서버가 오래 살아있어야 하는 인프라스터럭처가 클라우드의 분산형 서비스를 처리하는데 비효율적이라는데에는 많은 이유가 있다.

* 운영 복잡성의 증가
분산형 서비스 아키텍처가 생겨나고, 동적 확장 기능이 사용되면서 모니터링해야할 요소들이 더욱 많아졌다. 그런데 전통적인 방식(죽지 않는 서버 운영 방식)으로는 수백, 수천대 서버들의 설정을 패치하고 업데이트하기가 어렵고 시간도 엄청 소모된다. 

* 상대적으로 느린 배포와 더 많은 실패
인프라스트럭처가 전통적인 유지보수 방식(스트립트든 설정관리 도구를 사용하던) 으로 관리되면, 유리몸([snowflake server](https://martinfowler.com/bliki/SnowflakeServer.html))과 같이 깨지기 쉽다. 그리고 소스관리 프로세스에서 직접 현황을 보지 않고서는 현재 인프라스트럭처 상태를 정확히 파악할 수 없다. 인프라스트럭처가 예상치 못하게 작동하고, 설정 변경을 추적하며 시간을 소비하고, 어플리케이션을 실행하면서 디버깅을 하다보면 고객과의 약속은 깨질수 밖에 없다.

* 장애를 감소시키기 위한 에러와 위험요소 파악
오래살지만 변하기 쉬운(long-lived, mutable) 전통적인 시스템은 장애피해를 막기 위한 방법으로 에러와 위험요소 파악을 우선시 한다. 하지만 거의 매일 버그리포트가 나오고, 위험한 공격이 계속되는 상황에서 이제 우리는 이런 원인 파악이 부질없는 짓(Sisyphean undertaking)이라는 걸 알게되었다.   

* 예방 훈련
전통적인 인프라스트럭처 상황에서 자동화를 구현한다 하더라도 예기치 못한 방식으로 장애가 발생할 수 있다. 예를 들어 클라우드 제공자가 업데이트나 패치를 위해 하위 인스턴스를 재부팅할 때 처럼 말이다. 우리가 수동으로 인프라스트럭처를 생성하고 관리하면, 그래서 II 자동화 방식을 따르지 않는 상황에서는 이런 이벤트 자체가 예상치 않은 예방 훈련이 될 것이다.

## 불변의 인프라스트럭처가 보여주는 희망
II는 마치 자연이 인체 시스템을 관리하는 원리와 상당히 유사하다. 인체가 활동하는데 필요한 기본 작동방식은 인체 구성요소가 지속적으로 파괴되고 대체되는 것이다. 이 방식은 면역 시스템에도 동일하게 적용되어 건강상태를 유지하기 위해 세포를 파괴하고, 성장시스템에도 적용되어 여러가지 인체 요소가 파괴와 대체를 통해 성숙해지게 된다. 인간 개개인은 내부 요소가 지속적으로 교체되면서 자아와 자의식을 유지하게 된다. 이런 인체 시스템은 II 패턴과 하나도 다를게 없다.

불변의 인프라스트럭처가 가지는 잇점은 여러가지가 있지만 그 사전 조건은 이런 접근 방법이 어플리케이션에 적용되어 배포가 완전 자동화되고, 복구 방법도 마련되어야 한다.

* 운영의 단순화
완전 자동화 배포 도구를 활용하면 초기의 "완전(known-good)" 상태를 유지하면서 이전 버전의 구성요소를 새로운 버전으로 바꿀 수 있다. 그리고 II 환경에서는 변경되는 유지보수 도구때문에 발생하는 변화를 추적할 필요가 없기 때문에, 다수의 인스턴스를 유지하는 것도 훨씬 간단해 진다.

* 지속적인 배포와 실패 최소화
II환경에서 어떤 어플리케이션이 돌아야하고 어떤게 작동하는지 알고 있다. 그리고 업데이트를 배포하는 것과 같은 실제 운영환경에서 매우 일반적이고, 반복되는 작업도 훨씬 적은 실패 확율로 진행할 수 있다. 모든 변경은 소스 관리, CI/CD 배포 프로스세에 의해 트래킹된다.

* 에러와 위험요소 최소화
모든 서비스들은 복잡한 하드웨어/소프트웨어 스택위에서 만들어진다. 그리고 시간이 지남에 따라 잘못되게 된다. 기존 인스턴스를 유지하는 대신 자동으로 새로운 인스턴스를 생성함으로 인해 주기적으로 그리고 자주 인스턴스를 재생산할 수 있다. 이 방식은 설정 변경의 위험과 최약성 감소 그리고 SLA(service level agreement)를 유지하는데 매유 효과적이다. 기존 환경에서는 유지보수 훈련이 근본적으로 장애가 발생하기 쉽다.

* 클라우드 재부팅? No Problem.
II환경에서는 운영되는 서비스가 완전 자동화되어 복구될 수 있도록 구현된다. 따라서 클라우드 제공자가 하위 인스턴스를 재부팅시킨다 하더라도 최소한의 어플리케이션 영향도를 가지고 다뤄지게 된다.

![mutable and immutable infrastructure image](https://d3ansictanv2wj.cloudfront.net/immutable_infrastructure-8346d81e892e98c1308f707a037f4040.gif)

우리가 랙 안의 물리적인 하드웨어를 관리한다면, 당연히 유지보수를 위해 수동으로 관리해야 한다. 왜냐하면 손으로 직접 하드웨어를 구성했기 때문이다. 하지만 논리적으로 분리된 컴퓨트 인스턴스 API 콜을 통해서 클라우드 환경에서 생성될 수 있다. "박스 유지보수(maintaing boxes)"는 지능적으로 관리해야 하는 제약사항(intellectual ball and chain)이다. 유지보수를 하다보면 잘못된 부분에 힘쓰고 업무부하가 발생하게 된다. 이 부분을 포기하면, 정말 신경써야하는 어플리케이션 성공에 집중할 수 있게 된다. 또한 높은 유지보수 비용을 끌어내리고 새로운 패턴 적용의 어려움을 회피할 수있다.
